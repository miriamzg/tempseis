#!/bin/bash


source activate MASTERS_WORKING 

file="CMTSOLUTION_200807050212A_GCMT"
filtering="fortran_format_20_70_20_100_45_100"



################################################################################

rm Inversion/NA/data/rfi_files/OBS/*
rm Inversion/NA/src/rfi_subs/point_source/*
rm Inversion/NA/src/rfi_subs/kernels/*

cp database/$file/$filtering/point_source/* Inversion/NA/src/rfi_subs/point_source/
echo "coping point source done!"
cp database/$file/$filtering/observed_data/* Inversion/NA/data/rfi_files/OBS/
echo "copying observed data Done!"
for d  in database/$file/$filtering/derivatives/*
do
echo $d
cp $d  Inversion/NA/src/rfi_subs/kernels/
done
echo "copying derivatives done!"
###############################################################################################################################################################

cd /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Preparation

cat > /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Preparation/scalar_moment.py << *
import os
import matplotlib.pylab as plt
import numpy as np
import sys
from matplotlib import cm
from operator import itemgetter
import operator
import glob
import re
from math import sqrt



Event_code = "$file"
Data_folder = "/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/database/" + Event_code
#inversion_code = "unbounded"
#Results_folder = "/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Results/"     + Event_code + "/" + inversion_code
Result_folder = sys.argv[1]


os.chdir(Data_folder)
filename ="$file"

# all of this is just pulling out the moments infomration from the CMTsolution file ( I THINK THIS IS A STUPID WAY TO DO THIS
f = open(filename,"r")
lines = f.readlines()
l=[]
for i in range(7, 13):
    s = lines[i]
    match_number = re.compile('-?\ *[0-9]+\.?[0-9]*(?:[Ee]\ *-?\ *[0-9]+)?')
    final_list = [float(x) for x in re.findall(match_number, s)]
    l.append(final_list)


Mrr = l[0]
Mtt = l[1]
Mpp = l[2]
Mrt = l[3]
Mrp = l[4]
Mtp = l[5]

#this is just putting the exponetials back together becuase it did not like the way the exponetials were written becuase they had a plus in front so I removed it and then put the bits back together
Mrr = Mrr[0] * (10**Mrr[1]) * 0.00000010 #converted to Nm
Mtt = Mtt[0] * (10**Mtt[1]) * 0.00000010
Mpp = Mpp[0] * (10**Mpp[1]) * 0.00000010
Mrt = Mrt[0] * (10**Mrt[1]) * 0.00000010
Mrp = Mrp[0] * (10**Mrp[1]) * 0.00000010
Mtp = Mtp[0] * (10**Mtp[1]) * 0.00000010

#now I am going to attempt to work out the moment magnitude using the formula from the shearer textbook

Mo = (1/sqrt(2)) * (sqrt((Mrr**2)+(Mtt**2)+(Mpp**2)+(Mrt**2)+(Mrp**2)+(Mtp**2)))

os.chdir(Result_folder)
f = open('scalar_moment.txt', 'wb')
f.write("%d" % Mo)
f.close()

#Amin = 3
#Amax = 6
#c =1
#stress_drop = (( c* Mo)/  ((sqrt((Amax*Amin*1000*1000))) **(3)))/ 1000000



#os.chdir(Results_folder)
#f = open("best_parameters.txt","r")
#lines = f.readlines()
#Amin_all =  lines[7].split()
#Amin = Amin_all[1]
#Amin = float(Amin)
#Amax_all =  lines[6].split()
#Amax = Amax_all[1]
#Amax = float(Amax)
#print Amin
#print Amax


# calculating the stress drop and writing it to a file
#c =1
#area =Amin * Amax
#root_area  = sqrt (area)
#stress_drop = (c* scalar_moment)/ root_area
#print stress_drop
#f = open('stress_drop.txt', 'wb')
#f.write("The stress drop is %d" % stress_drop)
#f.close()

*

cat > /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Preparation/create_station_file_azimut.py << ~
# -*- coding: utf-8 -*-
import os
import sys
import glob
sys.path.insert(0, '../../lib/')
from functions import *
import numpy as np
from matplotlib import cm
from adjustText import adjust_text


def get_station_coords(station):
	station_list = []
	lines = open("../../STATIONS").readlines()
	for i in range(0,len(lines)):
		sta = lines[i].split()[0]
		st_lat = float(lines[i].split()[2])
		st_lon = float(lines[i].split()[3])
		station_list.append([sta, st_lat, st_lon])


	for j in range(0,len(station_list)):
		if station == station_list[j][0]:
			st_lat = station_list[j][1]
			st_lon = station_list[j][2]
			break

	return st_lat, st_lon

def use_it_or_not(station, comp, wavetype, data2use):
	use_it = "N"
	for i in range(0,len(data2use)):
			if station == data2use[i][0] and comp == data2use[i][1] and wavetype == data2use[i][2]:
				use_it = data2use[i][3]
				break
	return use_it

def calculate_initial_compass_bearing(pointA, pointB):

    if (type(pointA) != tuple) or (type(pointB) != tuple):
        raise TypeError("Only tuples are supported as arguments")
    
    lat1 = math.radians(pointA[0])
    lat2 = math.radians(pointB[0])

    diffLong = math.radians(pointB[1] - pointA[1])

    x = math.sin(diffLong) * math.cos(lat2)
    y = math.cos(lat1) * math.sin(lat2) - (math.sin(lat1)
                                       * math.cos(lat2) * math.cos(diffLong))

    initial_bearing = math.atan2(x, y)

    initial_bearing = math.degrees(initial_bearing)
    compass_bearing = (initial_bearing + 360) % 360
    
    return compass_bearing


folder = "/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/database/$file/"
cmt_file =  folder + "$file"
use_selection_file = "yes"


dist_min_P = 20.
dist_max_P = 90.
dist_min_S = 20.
dist_max_S = 90.
dist_min_W = 40.
dist_max_W = 120.

selection_file = folder + "$filtering/station2use.txt"

use_selection_file = "yes"







lines = open(cmt_file).readlines()
ev_lat = float(lines[4].split()[1])
ev_lon = float(lines[5].split()[1])


stations2skip = [] #["GAR", "INCN"]



if use_selection_file == "yes":
	data2use = []
	lines = open(selection_file).readlines()
	for i in range(1,len(lines)):
		sta = lines[i].split()[0]
		comp = lines[i].split()[1]
		wavetype = lines[i].split()[2]
		use = lines[i].split()[3]
		data2use.append([sta, comp, wavetype, use])



#=====================================================================
#	write station file
#=====================================================================
print "Writing station file..."
filelist = glob.glob("../NA/data/rfi_files/OBS/*")
out = open("rfi.in","w")
out.write("#\n# Input file for receiver function inversion specific information\n#\n")
out.write("rfi_param                              /* input model   */\n")
out.write("rfi_models                             /* output models */\n")
out.write(str(len(filelist))+"\t\t\t/* nwave */\n")
n = 0

use_it = "N"

for wt in ["P","S"]:
	print "Preparing " + wt + " waves"
	bbz = []
	if wt == "P":
		dist_min = dist_min_P
		dist_max = dist_max_P
	if wt == "S":
		dist_min = dist_min_S
		dist_max = dist_max_S
        #if wt == "W":
        #dist_min = dist_min_W
#dist_max = dist_max_W

	bbaz = []
	ddist = []
	ss_list = []
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='polar')
	ax.set_theta_zero_location('W',offset=-90)
	ax.set_theta_direction(-1)

	for fl in sorted(filelist):
		station = fl.split("/")[-1].split("_")[0]
		wavetype = fl.split("/")[-1].split("_")[2]
		data_name = fl.split("/")[-1].split("_ff")[0]
		comp = fl.split("/")[-1].split("_")[1]

		st_lat, st_lon = get_station_coords(station)
		dist = distance(st_lat, st_lon, ev_lat, ev_lon)[0]
		st = (st_lat, st_lon)
		ev = (ev_lat, ev_lon)
		baz = calculate_initial_compass_bearing(ev, st)
		use_it = use_it_or_not(station, comp, wavetype, data2use)
		#use_it = "Y"

		if wavetype == wt and use_it == "Y" and dist >= dist_min and dist <= dist_max:
			if station not in ss_list:
				ss_list.append(station)
				bbaz.append(baz)
				ddist.append(dist)
				ax.scatter(math.radians(baz), dist, marker="^", c="g",s=70,zorder = 2)
				fig.suptitle( wt + " waves")

				ax.set_ylim(0,90) 
				ax.set_yticks(np.arange(10,90,10))
				ax.annotate(station, xy=(math.radians(baz), dist))
				n+=1


	baz_bins = np.arange(0,370,10.)
	counts, bins = np.histogram(bbaz, bins=baz_bins)

	plt.savefig("az_coverageTEST_"+wt+".pdf")
	plt.close()


	plt.hist(ddist, bins=100)
	plt.savefig("dist_hist"+wt+".png")
	plt.close()

	plt.hist(bbaz, bins=baz_bins)
	for i in range(0,len(counts)):
		b = (bins[i] + bins[i+1])/2.
		plt.scatter(b, counts[i])
	plt.savefig("baz_hist_"+wt+".png")
	plt.close()


	fig = plt.figure()
	ax2 = fig.add_subplot(111, projection='polar')
	ax2.set_theta_zero_location('W',offset=-90)
	ax2.set_theta_direction(-1)
	ax2.set_xticks([0,3.14/2., 3.14, 3*3.14/2.])
	for fl in sorted(filelist):
		data_name = fl.split("/")[-1]
		station = fl.split("/")[-1].split("_")[0]
		wavetype = fl.split("/")[-1].split("_")[2]
		data_name = fl.split("/")[-1].split("_ff")[0]
		comp = fl.split("/")[-1].split("_")[1]

		st_lat, st_lon = get_station_coords(station)
		dist = distance(st_lat, st_lon, ev_lat, ev_lon)[0]
		if wt == "P":
			dist_min = dist_min_P
			dist_max = dist_max_P
		if wt == "S":
			dist_min = dist_min_S
			dist_max = dist_max_S
		if wt == "W":
			dist_min = dist_min_W
			dist_max = dist_max_W

		st = (st_lat, st_lon)
		ev = (ev_lat, ev_lon)
		baz = calculate_initial_compass_bearing(ev, st)
		use_it = use_it_or_not(station, comp, wavetype, data2use)
	#	use_it = "Y"
		
		
		if wavetype == wt and use_it == "Y" and dist >= dist_min and dist <= dist_max:
			for i in range(0,len(bins)-1):
				baz_min = bins[i]
				baz_max = bins[i+1]
				

				if baz_min not in bbz:
					bbz.append(baz_min)
					plt.axvline(math.radians(baz_min), color="0.8", zorder=0)

				if baz >= baz_min and baz <= baz_max:
					density_sta = 1/float(counts[i])
					print counts[i], density_sta
					break

			#print station, comp, wavetype, dist, baz, density_sta
			c = plt.scatter(math.radians(baz), dist, c=density_sta, vmin=0.0, vmax=1.0, cmap=cm.jet, zorder=10, marker="^", s=40)
			ax2.annotate(station, xy=(math.radians(baz), dist))
			out.write(data_name + "\n")
			weight = str(round(density_sta,3))
			out.write(weight+ "\n")
	plt.ylim(0,dist_max)

	plt.colorbar(c)	

	plt.savefig("tmp_"+wt+".png")
	plt.close()

out.write("1                                       /* iwrite_models */")
out.close()



out = open("rfi.in_new","w")
lines = open("rfi.in","r").readlines()
for i in range(0,len(lines)):
	
	if i == 5:
		out.write(str(n)+"\t\t\t/* nwave */\n")
	else:
		out.write(lines[i])
out.close()
os.system("mv rfi.in_new rfi.in")


os.system("cp rfi.in ../NA/data/rfi_files")

~

python create_station_file_azimut.py

cp /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Preparation/az_coverageTEST*.pdf /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/templots

#cd /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion

#cp /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Preparation/rfi.in /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/NA/data/rfi_files/

###############################################################################################################################################################

cat > /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Plot_results/plot_seismograms2_indipendant.py << *

import os
import sys
import numpy as np 
import glob
import matplotlib.pylab as plt
from matplotlib import ticker

formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_scientific(True) 
formatter.set_powerlimits((-2,2))


def time_windowing(list):
	dt = 1.0
	integral = []
	somma = 0.0
	for i in range(0,len(list.real)):
		#print trRsynt.data[i]
		somma += abs(list[i].real)
		integral.append(somma)
	
	ymin = (max(integral) - min(integral)) * 0.05
	ymax = (max(integral) - min(integral)) * 0.95 	

	istart = 0.0
	iend = 0.0
	for i in range(0,len(integral)):
		if integral[i] >= ymin :
			istart = i
			break
	for i in range(0,len(integral)):
		if integral[i] >= ymax:
			iend = i
			break

	tstart = istart * dt
	tend = iend * dt 

	return tstart, tend

	


#inversion_code = "test7.3"

#results_folder = sys.argv[1]
results_folder = '/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Results/$file/newdat/aspect_confined_SHfilt_newlimdat_.500'
result_file = '/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/templots'


observed_folder = results_folder + "/observed/"
predicted_folder = results_folder + "/best_predicted/"
point_source_folder = "../NA/src/rfi_subs/point_source/"




comp_list = ["Z","R","T"]




station_comp = []
filelist = glob.glob(observed_folder + "*_P_observed.asc")
for i in range(0,len(filelist)):
	station = filelist[i].split("/")[-1].split("_")[0]
	comp = filelist[i].split("/")[-1].split("_")[1]
	station_comp.append([station, comp])

station_comp = sorted(station_comp)

fig = plt.figure(1, figsize=(9, 10))
plt.subplots_adjust(bottom=0.05,
					 left=0.07, right = 0.98,
					 top=0.95, hspace=0.5,
					 wspace=0.25)


ncolumn = 2
n = 1
for i in range(0,len(station_comp)):
	#try:
		station = station_comp[i][0]
		comp = station_comp[i][1]
	
		wavetype = "P"

		observed = observed_folder + station + "_" + comp + "_"+wavetype + "_observed.asc"
		predicted = predicted_folder + station + "_" + comp + "_" + wavetype + "_best_predicted.asc"
		point_source = point_source_folder + station + "_" + comp + "_"+wavetype + "_ps"

		lines =  open(observed).readlines()
		oobsf, oobsr, oobsi, cc = [],[],[],[]
		for i in range(0,len(lines)):
			obsf = float(lines[i].split()[0])
			obsr = float(lines[i].split()[1])
			obsi = float(lines[i].split()[2])
			oobsf.append(obsf/6.28)
			oobsr.append(obsr)
			oobsi.append(obsi)
			c = complex(obsr, obsi)
			cc.append(c)
		obs_complex = np.asarray(cc, dtype=complex)

		lines =  open(point_source).readlines()
		ppsf, ppsr, ppsi, cc = [],[],[],[]
		for i in range(2,len(lines)):
			psf = float(lines[i].split()[0])
			psr = float(lines[i].split()[1])
			psi = float(lines[i].split()[2])
			ppsf.append(psf/6.28)
			ppsr.append(psr)
			ppsi.append(psi)
			c = complex(psr, psi)
			cc.append(c)
		ps_complex = np.asarray(cc, dtype=complex)		


	 	lines = open(predicted).readlines()
		ppredf, ppredr, ppredi, cc = [],[],[],[]
		for i in range(0,len(lines)):
			predf = float(lines[i].split()[0])
			predr = float(lines[i].split()[1])
			predi = float(lines[i].split()[2])
			ppredf.append(predf/6.28)
			ppredr.append(predr)
			ppredi.append(predi)
			c = complex(predr, predi)
			cc.append(c)
		
		pred_complex = np.asarray(cc, dtype=complex)


	 	npoints = len(obs_complex)
	 	obs_inv =  np.fft.ifft(obs_complex, n=npoints)
	 	ps_inv =  np.fft.ifft(ps_complex, n=npoints)
	 	pred_inv =  np.fft.ifft(pred_complex, n=npoints)

	 	mft = 0.0
	 	for j in range(0,len(obs_inv)):
	 		(obs_inv[j].real - pred_inv[j].real)**2
	 		mft += (obs_inv[j].real - pred_inv[j].real)**2
	 	mft = np.sqrt(mft)
	 	mft = format(mft, '1.1e')

	 	tstart, tend = time_windowing(obs_inv)

	 	a = 1+int((len(station_comp)+1)/float(ncolumn))
	 	b = ncolumn
	 	c = n
	 	ax1 = fig.add_subplot(111)
	 	print a,b,c
	 	ax = plt.subplot(a,b,c)
	 	ax.set(xlim=(300, 600))
	 	ax.ticklabel_format(style='sci',scilimits=(-3,4),axis='both')
	 	plt.plot(np.arange(0,len(obs_inv),1), obs_inv.real, color="black", label="Observed", linewidth=1.5 , zorder=1)	 	
	 	plt.plot(np.arange(0,len(ps_inv),1), ps_inv.real, color="0.6", label="Point source", linewidth=2.0 , zorder=0)
	 	plt.plot(np.arange(0,len(obs_inv),1), pred_inv.real, color="red", label="Predicted", linewidth=1.0 , zorder=2 )
	 	plt.grid(True)
	 #	plt.ylabel(wavetype + " waves")
	 	ax1.spines['top'].set_color('none')
	 	ax1.spines['bottom'].set_color('none')
	 	ax1.spines['left'].set_color('none')
	 	ax1.spines['right'].set_color('none')
	 	ax1.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	 	 
         #if (c - 1) % b   != 0 :
         #ax.set_yticklabels([])
	 	if c <= ( len(station_comp) - b ) : # this is stupid as it will need changing for each different thing 
  			print c 
 			ax.set_xticklabels([])
		#ax.set_xticklabels([])
		plt.xlim(tstart-30, tend+90)
		if len(station) == 3:
			plt.annotate(station+" "+ comp, xy=(0.75, 0.65), xycoords='axes fraction', fontsize=11)
			plt.annotate( str(mft),  xy=(0.75, 0.15), xycoords='axes fraction', fontsize=11 )
		if len(station) == 4:
			plt.annotate(station+" "+ comp, xy=(0.75, 0.65), xycoords='axes fraction', fontsize=11)
			plt.annotate( str(mft),  xy=(0.75, 0.15), xycoords='axes fraction', fontsize=11 )
	  	n += 1


#	except:
#		pass
#plt.show()
plt.grid(True)
#plt.setp([a.get_yticklabels() for a in ax[:, 1]], visible=False)
          #
          #for a in ax[0, :]], visible=False)
#plt.setp([a.get_yticklabels() for a in ax[:, 1]], visible=False)
#ax.ticklabel_format(style='sci',scilimits=(-3,4),axis='both')
fig.text(0.5, 0.025, 'Time (s)', ha='center', va='center',fontsize=12 )
fig.text(0.025, 0.5, 'Displacement (m) ', ha='center', va='center', rotation='vertical',fontsize=12 )
plt.savefig(result_file + "/seismograms_PTEST.pdf")
#plt.show()
plt.close()


#===================================================================
station_comp = []
filelist = glob.glob(observed_folder + "*_S_observed.asc")
for i in range(0,len(filelist)):
	station = filelist[i].split("/")[-1].split("_")[0]
	comp = filelist[i].split("/")[-1].split("_")[1]
	station_comp.append([station, comp])

station_comp = sorted(station_comp)

fig = plt.figure(1, figsize=(9, 10))
plt.subplots_adjust(bottom=0.05,
					 left=0.07, right = 0.98,
					 top=0.95, hspace=0.5,
					 wspace=0.25)


ncolumn = 2
n = 1
for i in range(0,len(station_comp)):
	try:
		station = station_comp[i][0]
		comp = station_comp[i][1]
	
		wavetype = "S"

		observed = observed_folder + station + "_" + comp + "_"+wavetype + "_observed.asc"
		predicted = predicted_folder + station + "_" + comp + "_" + wavetype + "_best_predicted.asc"
		point_source = point_source_folder + station + "_" + comp + "_"+wavetype + "_ps"


		lines =  open(observed).readlines()
		oobsf, oobsr, oobsi, cc = [],[],[],[]
		for i in range(0,len(lines)):
			obsf = float(lines[i].split()[0])
			obsr = float(lines[i].split()[1])
			obsi = float(lines[i].split()[2])
			oobsf.append(obsf/6.28)
			oobsr.append(obsr)
			oobsi.append(obsi)
			c = complex(obsr, obsi)
			cc.append(c)
		obs_complex = np.asarray(cc, dtype=complex)

		
		lines =  open(point_source).readlines()
		ppsf, ppsr, ppsi, cc = [],[],[],[]
		for i in range(2,len(lines)):
			psf = float(lines[i].split()[0])
			psr = float(lines[i].split()[1])
			psi = float(lines[i].split()[2])
			ppsf.append(psf/6.28)
			ppsr.append(psr)
			ppsi.append(psi)
			c = complex(psr, psi)
			cc.append(c)
		ps_complex = np.asarray(cc, dtype=complex)	

	 	lines = open(predicted).readlines()
		ppredf, ppredr, ppredi, cc = [],[],[],[]
		for i in range(0,len(lines)):
			predf = float(lines[i].split()[0])
			predr = float(lines[i].split()[1])
			predi = float(lines[i].split()[2])
			ppredf.append(predf/6.28)
			ppredr.append(predr)
			ppredi.append(predi)
			c = complex(predr, predi)
			cc.append(c)
		
		pred_complex = np.asarray(cc, dtype=complex)


	 	npoints = len(obs_complex)
	 	obs_inv =  np.fft.ifft(obs_complex, n=npoints)
	 	pred_inv =  np.fft.ifft(pred_complex, n=npoints)
	 	ps_inv =  np.fft.ifft(ps_complex, n=npoints)


	 	mft = 0.0
	 	for j in range(0,len(obs_inv)):
	 		(obs_inv[j].real - pred_inv[j].real)**2
	 		mft += (obs_inv[j].real - pred_inv[j].real)**2
	 	mft = np.sqrt(mft)
	 	mft = format(mft, '1.1e')

	 	tstart, tend = time_windowing(obs_inv)

	 	a = 1+int((len(station_comp)+1)/float(ncolumn))
	 	b = ncolumn
	 	c = n
	 	ax1 = fig.add_subplot(111)
	 	print a,b,c
	 	ax = plt.subplot(a,b,c)
	 	ax.set(xlim=(300, 600))
	 	ax.ticklabel_format(style='sci',scilimits=(-3,4),axis='both')
	 	plt.plot(np.arange(0,len(obs_inv),1), obs_inv.real, color="black", label="Observed", linewidth=1.5 , zorder=1)	 	
	 	plt.plot(np.arange(0,len(ps_inv),1), ps_inv.real, color="0.6", label="Point source", linewidth=2.0 , zorder=0)
	 	plt.plot(np.arange(0,len(obs_inv),1), pred_inv.real, color="red", label="Predicted", linewidth=1.0 , zorder=2 )
	 	plt.grid(True)
	 #	plt.ylabel(wavetype + " waves")
	 	ax1.spines['top'].set_color('none')
	 	ax1.spines['bottom'].set_color('none')
	 	ax1.spines['left'].set_color('none')
	 	ax1.spines['right'].set_color('none')
	 	ax1.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	 	 
         #if (c - 1) % b   != 0 :
         #ax.set_yticklabels([])
	 	if c <= ( len(station_comp) - b ) : # this is stupid as it will need changing for each different thing 
  			print c 
 			ax.set_xticklabels([])
		#ax.set_xticklabels([])
		plt.xlim(tstart-30, tend+90)
		if len(station) == 3:
			plt.annotate(station+" "+ comp, xy=(0.75, 0.65), xycoords='axes fraction', fontsize=11)
			plt.annotate( str(mft),  xy=(0.75, 0.14), xycoords='axes fraction', fontsize=11 )
		if len(station) == 4:
			plt.annotate(station+" "+ comp, xy=(0.75, 0.65), xycoords='axes fraction', fontsize=11)
			plt.annotate( str(mft),  xy=(0.75, 0.14), xycoords='axes fraction', fontsize=11 )
	  	n += 1
	except:
		pass
fig.text(0.5, 0.02, 'Time (s)', ha='center', va='center',fontsize=12 )
fig.text(0.02, 0.5, 'Displacement (m) ', ha='center', va='center', rotation='vertical',fontsize=12 )
plt.savefig(result_file + "/seismograms_STEST.pdf")
#plt.show()
plt.close()



*

python /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Plot_results/plot_seismograms2_indipendant.py

############################################################################################################################################################################################################################################
cat > /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Plot_results/plot_results_subplot.py << *

import os
import matplotlib.pylab as plt
import numpy as np
import sys
from matplotlib import cm
from operator import itemgetter
import operator
from matplotlib import rc



#code = "test7.3"
Event_code = "$file"
inversion_code = "aspect_confined_SHfilt_newlimdat_.500"
#result_folder = sys.argv[1]
result_folder = "/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Results/"    + Event_code + "/newdat/" + inversion_code
#result_folder = sys.argv[1]
result_file = result_folder + "/rfi_models"
#fault_file = "../results/" + code + "/201604151625A_TEST0_info.txt"
scalar_moment_file = result_folder + "/scalar_moment.txt"


# lines = open(fault_file, "r").readlines()
# phi_t = float(lines[11].split()[1])
# Amax_t = float(lines[12].split()[1])
# Amin_t = float(lines[13].split()[1])
# Duration_t = float(lines[14].split()[1])
# dip_t =  float(lines[7].split()[1])
# strike_t =  float(lines[8].split()[1])
# E_t = Amin_t / Amax_t


#Amax_t = 30.
#Amin_t = 5

#Area_t = Amax_t * Amin_t
#Duration_t = 7.5
#phi_t = 0.0
#v_abs_t = 4.0
#v_angle_t = 0.0
#rc_mod_t = 0.0
#rc_ang_t = 0.0
#tc_t = 3.25

perc_treshold = 5.

synt = "n"

mmisfit, AAmax, AAmin, pphi, sstrike, iindex, EE, ddip, dduration = [],[],[],[],[],[],[],[],[]
AArea = []
AAmax_real, AAmin_real  = [], []
vv_abs, vv_ang, rrc_mod, rrc_ang, dduration_real = [], [],[],[],[]
rrc = []
ttc = []
mmft = []
nmodel = []
Sstress_drop = []
Sstress_drop_Mcguire = []
Sstress_drop_Amax = []
c = 1

#defining Mo from where it is saved in a text file
Mo = open(scalar_moment_file).readlines()
Mo = int(Mo[0])

lines = open(result_file).readlines()
mod_initial = int(lines[0].split()[0])
mod_per_iter = int(lines[1].split()[0])
n_iter = int(lines[2].split()[0])
n = 0
for i in range(3,len(lines)):
    if len(lines[i].split()) != 0:
        if lines[i].split()[0] == "model:":
            
            iindex.append(n)
            misfit = float(lines[i].split("value:")[1])
            
            rc_mod, rc_ang  = float(lines[i+1].split()[2]),float(lines[i+1].split()[3])
            tc = float(lines[i+2].split()[2])
            duration = float(lines[i+3].split()[1])
            v_abs = float(lines[i+4].split()[2])
            v_ang = float(lines[i+4].split()[5])
            Amax = (float(lines[i+5].split()[1]))
            Amin = float(lines[i+5].split()[3])
            phi =  float(lines[i+5].split()[5])
            
            strike =  float(lines[i+6].split()[1])
            dip = float(lines[i+6].split()[3])
            
            
            mmisfit.append([misfit,n])
            mmft.append(misfit)
            #EE.append(E)
            rrc_mod.append(rc_mod)
            rrc_ang.append(rc_ang)
            ttc.append(tc)
            AAmax.append(Amax)
            AAmax_real.append(Amax*np.sqrt(3.))
            AAmin.append(Amin)
            AAmin_real.append(Amin*np.sqrt(3.))
            
            AArea.append(Amax*np.sqrt(3.)*Amin*np.sqrt(3.))
            Sstress_drop.append((( c* Mo)/((np.sqrt(Amax*Amin*1000*1000*3))**(3)))/1000000)
            pphi.append(phi)
            sstrike.append(strike)
            ddip.append(dip)
            dduration.append(duration)
            dduration_real.append(duration*np.sqrt(3.))
            vv_abs.append(v_abs)
            vv_ang.append(v_ang)
            nmodel.append(n)
            n += 1

i_best = min(enumerate(mmft), key=itemgetter(1))[0]
#Amax_best =  AAmax_real[i_best]
#Amin_best =  AAmin_real[i_best]
#Phi_best =   pphi[i_best]
#Duration_best =  dduration_real[i_best]
#v_abs_best = vv_abs[i_best]
#v_ang_best = vv_ang[i_best]
#tc_best = ttc[i_best]


min_mft = min(mmft)
mft_treshold = min_mft  * (1 + perc_treshold / 100.)



dduration_bests, vv_abs_bests, vv_angle_bests,     AAmax_bests, AAmin_bests, pphi_bests, ttc_bests, stress_drop_bests,stress_drop_Mcguire_bests,stress_drop_Amax_bests = [],[],[],[],[],[],[],[],[],[]
iindex_bests=[]
j = 0
for i in range(3,(len(lines)-1000)):
    if len(lines[i].split()) != 0:
        if lines[i].split()[0] == "model:":
            
            misfit = float(lines[i].split("value:")[1])
            if misfit <= mft_treshold:
                
                rc_mod, rc_ang  = float(lines[i+1].split()[2]),float(lines[i+1].split()[3])
                tc = float(lines[i+2].split()[2])
                duration = float(lines[i+3].split()[1])*np.sqrt(3.)
                v_abs = float(lines[i+4].split()[2])
                v_ang = float(lines[i+4].split()[5])
                Amax = (float(lines[i+5].split()[1]))*np.sqrt(3.)
                Amin = float(lines[i+5].split()[3])*np.sqrt(3.)
                phi =  float(lines[i+5].split()[5])
                stress_drop =(( c* Mo)/  ((np.sqrt((Amax*Amin*1000*1000))) **(3))/1000000)
                stress_drop_Mcguire =(( c* Mo)/  (np.pi * Amax*Amin*Amin))/1e+15
                stress_drop_Amax =(( c* Mo)/  ((np.sqrt((Amax*Amax*1000*1000))) **(3))/1000000)
                ttc_bests.append([tc, misfit])
                dduration_bests.append([duration, misfit])
                vv_abs_bests.append([v_abs, misfit])
                vv_angle_bests.append([v_ang, misfit])
                AAmax_bests.append([Amax, misfit])
                AAmin_bests.append([Amin, misfit])
                pphi_bests.append([phi, misfit])
                stress_drop_bests.append([stress_drop,misfit])
                stress_drop_Mcguire_bests.append([stress_drop_Mcguire,misfit])
                stress_drop_Amax_bests.append([stress_drop_Amax,misfit])
                
                
                iindex_bests.append(j)
                j+=1



ttc_bests_sorted = sorted(ttc_bests, key=operator.itemgetter(1), reverse=False)    # ordino i misfit dal peggiore al migliore
dduration_bests_sorted = sorted(dduration_bests, key=operator.itemgetter(1), reverse=False)    # ordino i misfit dal peggiore al migliore
vv_abs_bests_sorted = sorted(vv_abs_bests, key=operator.itemgetter(1), reverse=False)    # ordino i misfit dal peggiore al migliore
vv_angle_bests_sorted = sorted(vv_angle_bests, key=operator.itemgetter(1), reverse=False)
AAmax_bests_sorted = sorted(AAmax_bests, key=operator.itemgetter(1), reverse=False)
AAmin_bests_sorted = sorted(AAmin_bests, key=operator.itemgetter(1), reverse=False)
pphi_bests_sorted = sorted(pphi_bests, key=operator.itemgetter(1), reverse=False)
stress_drop_bests_sorted = sorted(stress_drop_bests, key=operator.itemgetter(1), reverse=False )
stress_drop_bests_Mcguire_sorted = sorted(stress_drop_Mcguire_bests, key=operator.itemgetter(1), reverse=False )
stress_drop_bests_Amax_sorted = sorted(stress_drop_Amax_bests, key=operator.itemgetter(1), reverse=False )

best_duration = round(dduration_bests_sorted[0][0],2)
best_v_abs = round(vv_abs_bests_sorted[0][0],2)
best_v_ang = round(vv_angle_bests_sorted[0][0],2)
best_Amax = round(AAmax_bests_sorted[0][0],2)
best_Amin = round(AAmin_bests_sorted[0][0],2)
best_phi = round(pphi_bests_sorted[0][0],2)
best_tc = round(ttc_bests_sorted[0][0],2)
best_stress_drop = round (stress_drop_bests_sorted[0][0],2)
best_stress_drop_Mcguire = round (stress_drop_bests_Mcguire_sorted[0][0],2)
best_stress_drop_Amax = round (stress_drop_bests_Amax_sorted[0][0],2)

min_duration = round(min(dduration_bests, key=operator.itemgetter(0))[0],2)
max_duration = round(max(dduration_bests, key=operator.itemgetter(0))[0],2)
min_v_abs = round(min(vv_abs_bests, key=operator.itemgetter(0))[0],2)
max_v_abs = round(max(vv_abs_bests, key=operator.itemgetter(0))[0],2)
min_v_ang = round(min(vv_angle_bests, key=operator.itemgetter(0))[0],2)
max_v_ang = round(max(vv_angle_bests, key=operator.itemgetter(0))[0],2)
min_Amax = round(min(AAmax_bests, key=operator.itemgetter(0))[0],2)
max_Amax = round(max(AAmax_bests, key=operator.itemgetter(0))[0],2)
min_Amin = round(min(AAmin_bests, key=operator.itemgetter(0))[0],2)
max_Amin = round(max(AAmin_bests, key=operator.itemgetter(0))[0],2)
min_phi = round(min(pphi_bests, key=operator.itemgetter(0))[0],2)
max_phi = round(max(pphi_bests, key=operator.itemgetter(0))[0],2)
min_tc = round(min(ttc_bests, key=operator.itemgetter(0))[0],2)
max_tc = round(max(ttc_bests, key=operator.itemgetter(0))[0],2)
min_stress_drop = round(min(stress_drop_bests,key=operator.itemgetter(0))[0],2)
max_stress_drop = round(max(stress_drop_bests,key=operator.itemgetter(0))[0],2)
min_stress_drop_Mcguire = round(min(stress_drop_Mcguire_bests,key=operator.itemgetter(0))[0],2)
max_stress_drop_Mcguire = round(max(stress_drop_Mcguire_bests,key=operator.itemgetter(0))[0],2)
min_stress_drop_Amax = round(min(stress_drop_Amax_bests,key=operator.itemgetter(0))[0],2)
max_stress_drop_Amax = round(max(stress_drop_Amax_bests,key=operator.itemgetter(0))[0],2)



print "***"
print "Duration: ", best_duration, "( ", min_duration," - ", max_duration," )"
print "v abs: ", best_v_abs,"( ", min_v_abs," - ", max_v_abs," )"
print "v ang: ",best_v_ang,"( ", min_v_ang," - ", max_v_ang," )"
print "A max: ", best_Amax,"( ", min_Amax," - ", max_Amax," )"
print "A min: ", best_Amin,"( ", min_Amin," - ", max_Amin," )"
print "Phi: ", best_phi,"( ", min_phi," - ", max_phi," )"
print "Stress Drop: ", best_stress_drop,"( ", min_stress_drop," - ",max_stress_drop," )"
print "Stress Drop Mcguire : ", best_stress_drop_Mcguire,"( ", min_stress_drop_Mcguire," - ",max_stress_drop_Mcguire," )"
print "Stress Drop Amax : ", best_stress_drop_Amax,"( ", min_stress_drop_Amax," - ",max_stress_drop_Amax," )"
print "***"




# Some statistics
rc_mean_module = round(np.median(rrc_mod),1)
rc_mean_angle = round(np.median(rrc_ang),1)


#T_mean = round(np.median(dduration_bests),1)
#T_sd = round(np.std(dduration_bests),1)

#Amax_mean = round(np.median(AAmax_bests),1)
#Amax_sd = round(np.std(AAmax_bests),1)

#Amin_mean = round(np.median(AAmin_bests),1)
#Amin_sd = round(np.std(AAmin_bests),1)

#phi_mean = round(np.median(pphi_bests),1)
#phi_sd = round(np.std(pphi_bests),1)

#v_abs_mean = round(np.mean(vv_abs_bests),1)
#v_abs_sd = round(np.std(vv_abs_bests),1)

#v_ang_mean = round(np.mean(vv_angle_bests),1)
#v_ang_sd = round(np.std(vv_angle_bests),1)

out = open(result_folder + "/best_parameters.txt","w")

out.write("*** threshold: "+str(perc_treshold)+"% ***\n")
out.write("Time centroid: "+str(best_tc)+"    \n")
out.write("spatial centroid (delta):\n")
out.write("rc module: " + "\t" + str(rc_mean_module) + "\n")
out.write("rc angle: " + "\t" + str(rc_mean_angle) + "\n")
out.write("Duration: " + "\t" + str(best_duration) + "\t( "+  str(min_duration) +  " - " + str(max_duration) + " )\n")
out.write("Amax: "  + "\t\t" + str(best_Amax) + "\t( " +  str(min_Amax) +  " - " + str(max_Amax) + " )\n")
out.write("Amin: "  + "\t\t"+ str(best_Amin) + "\t( "+  str(min_Amin) +  " - " + str(max_Amin) + " )\n")
out.write("Phi: " + "\t\t" + str(best_phi) + "\t( "+  str(min_phi) +  " - " + str(max_phi) + " )\n")
out.write("V abs: " + "\t\t" +  str(best_v_abs) + "\t( "+  str(min_v_abs) +  " - " + str(max_v_abs) + " )\n")
out.write("V ang: " + "\t\t" +  str(best_v_ang) + "\t( "+  str(min_v_ang) +  " - " + str(max_v_ang) + " )\n")
out.write("Stress Drop: " + "\t\t" +  str(best_stress_drop) + "\t( "+  str(min_stress_drop) +  " - " + str(max_stress_drop) + " )\n")
out.write("Stress Drop Mcguire: " + "\t\t" +  str(best_stress_drop_Mcguire) + "\t( "+  str(min_stress_drop_Mcguire) +  " - " + str(max_stress_drop_Amax) + " )\n")
out.write("Stress Drop Amax: " + "\t\t" +  str(best_stress_drop_Amax) + "\t( "+  str(min_stress_drop_Amax) +  " - " + str(max_stress_drop_Amax) + " )\n")
out.write("***")
out.close()




#==================================================================
plt.figure(1, figsize=(8.27, 11.69))
plt.subplot(311)
plt.scatter(iindex, rrc_mod, color="black",s=2, linewidth=0)
#plt.axhline(Amax_t, color="green")
plt.xlim(min(iindex),max(iindex))
#plt.axhline(rc_mod_t, color="lime", linewidth=2)
plt.ylabel("Rc module (km)")
plt.xlabel("\# model")

plt.subplot(312)
plt.scatter(iindex, rrc_ang, color="black",s=2, linewidth=0)
#plt.axhline(Amax_t, color="green")
plt.xlim(min(iindex),max(iindex))
#plt.axhline(rc_ang_t, color="lime", linewidth=2)
plt.ylabel("rc angle (deg)")
plt.xlabel("\# model")

plt.subplot(313)
plt.scatter(iindex, ttc, color="black",s=2, linewidth=0)
#plt.axhline(Amax_t, color="green")
plt.xlim(min(iindex),max(iindex))
#plt.axhline(tc_t, color="lime", linewidth=2)
plt.ylabel("tc (s)")
plt.xlabel("\# model")

plt.savefig(result_folder+"/centroid_evolution.png")
plt.close()

#==================================================================
plt.figure(1, figsize=(8.27, 11.69))
plt.subplot(711)
plt.scatter(iindex, zip(*mmisfit)[0], color="black",s=2, linewidth=0)
plt.ylabel("Misfit")
plt.xlabel("\# model")
#plt.yscale("log")
plt.xlim(min(iindex),iindex[-1000])
plt.ylim(0.1*min(zip(*mmisfit)[0]),10*max(zip(*mmisfit)[0]))

plt.subplot(712)
plt.scatter(iindex, AAmax_real, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*AAmax_bests)[0], color="red",s=2, linewidth=0,zorder=2)
plt.axhline(best_Amax, color="0.5", zorder=9)
plt.axhline(min_Amax, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_Amax, color="0.5", linestyle="--", zorder=9)
plt.xlim(min(iindex),iindex[-1000])
#if synt == "y":
#plt.axhline(Amax_t, color="lime", linewidth=2)
plt.ylabel("\$A_{max}\$ (km)")
plt.xlabel("\# model")

plt.subplot(713)
plt.scatter(iindex, AAmin_real, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*AAmin_bests)[0], color="red",s=2, linewidth=0,zorder=10)
plt.ylabel("\$A_{min}\$ (km)")
plt.xlabel("\# model")
plt.xlim(min(iindex),iindex[-1000])
#if synt == "y":
#plt.axhline(Amin_t, color="lime", linewidth=2)
plt.axhline(best_Amin, color="0.5", zorder=9)
plt.axhline(min_Amin, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_Amin, color="0.5", linestyle="--", zorder=9)

plt.subplot(714)
plt.scatter(iindex, pphi, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*pphi_bests)[0], color="red",s=2, linewidth=0,zorder=10)
plt.ylabel("$\Phi$ (deg)")
plt.xlabel("\# model")
#if synt == "y":
#plt.axhline(phi_t, color="lime", linewidth=2)
plt.axhline(best_phi, color="0.5", zorder=9)
plt.axhline(min_phi, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_phi, color="0.5", linestyle="--", zorder=9)
plt.xlim(min(iindex),iindex[-1000])

plt.subplot(715)
plt.scatter(iindex, dduration_real, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*dduration_bests)[0], color="red",s=2, linewidth=0,zorder=10)
plt.ylabel("$\Delta$ t (s)")
plt.xlabel("\# model")
plt.xlim(min(iindex),iindex[-1000])
#if synt == "y":
#plt.axhline(Duration_t, color="lime", linewidth=2)
plt.axhline(best_duration, color="0.5", zorder=9)
plt.axhline(min_duration, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_duration, color="0.5", linestyle="--", zorder=9)

plt.subplot(716)
plt.scatter(iindex, vv_abs, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*vv_abs_bests)[0], color="red",s=2, linewidth=0,zorder=10)
plt.ylabel("|v| (km/s)")
plt.xlabel("\# model")
plt.xlim(min(iindex),iindex[-1000])
#if synt == "y":
#plt.axhline(v_abs_t, color="lime", linewidth=2)
plt.axhline(best_v_abs, color="0.5", zorder=9)
plt.axhline(min_v_abs, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_v_abs, linestyle="--", zorder=9)

plt.subplot(717)
plt.scatter(iindex, vv_ang, color="black",s=2, linewidth=0)
plt.scatter(iindex_bests, zip(*vv_angle_bests)[0], color="red",s=2, linewidth=0,zorder=10)
plt.ylabel("v angle (deg)")
plt.xlabel("\# model")
plt.xlim(min(iindex),iindex[-1000])
#if synt == "y":
#plt.axhline(v_angle_t, color="lime", linewidth=2)
plt.axhline(best_v_ang, color="0.5", zorder=9)
plt.axhline(min_v_ang, color="0.5", linestyle="--", zorder=9)
plt.axhline(max_v_ang, color="0.5", linestyle="--", zorder=9)

plt.savefig(result_folder+"/parameters_evolution.png")
plt.close()

#==========================================================
plt.figure(1, figsize=(8.27,11.69))
font = {'size'   : 15}
plt.rc('font', **font)


plt.subplot(611)
plt.subplots_adjust(left=None, bottom=0.08, right=None, top=0.98, wspace=0.5, hspace=0.5)
plt.hist(AAmax_real, bins=100, color="C0")
#plt.axvline(Amax_best, color="red", linewidth=2)
#plt.axvline(Amax_mean-Amax_sd, color="red", linestyle="--")
#plt.axvline(Amax_mean+Amax_sd, color="red", linestyle="--")
#plt.axvline(Amax_t, color="lime", linewidth=2)
plt.xlabel("\$Amax (km\$)", size=18)
plt.ylabel("\# models")

plt.subplot(612)
plt.hist(AAmin_real, bins=100, color="C1")
plt.xlabel("Amin (km)", size=18)
plt.ylabel("\# models")
#plt.axvline(Amin_best, color="red", linewidth=2)
#plt.axvline(Amin_mean-Amin_sd, color="red", linestyle="--")
#plt.axvline(Amin_mean+Amin_sd, color="red", linestyle="--")
#plt.axvline(Amin_t, color="lime", linewidth=2)

plt.subplot(613)
plt.hist(pphi, bins=100, color="C2")
#plt.axvline(Phi_best, color="red", linewidth=2)
#plt.axvline(phi_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("Phi angle (degrees)", size=18)

plt.subplot(614)
plt.hist(dduration_real, bins=100, color="C3")
#plt.axvline(Duration_best, color="red", linewidth=2)
#plt.axvline(Duration_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("Duration (seconds)", size=18)

plt.subplot(615)
plt.hist(vv_abs, bins=100, color="C4")
#plt.axvline(v_abs_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("|v| (km/s)", size=18)

plt.subplot(616)
plt.hist(vv_ang, bins=100, color="C5")
#plt.axvline(v_angle_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("v angle (degrees)", size=18)

plt.savefig(result_folder+"/hist1.png")
plt.close()

#=======================================================
plt.figure(1, figsize=(8.27,11.69))
plt.subplot(611)
plt.subplots_adjust(left=None, bottom=0.08, right=None, top=0.98, wspace=0.5, hspace=0.5)
plt.hist(AAmax_real, bins=100, color="C0")
#plt.axvline(Amax_best, color="red", linewidth=2)
#plt.axvline(Amax_mean-Amax_sd, color="red", linestyle="--")
#plt.axvline(Amax_mean+Amax_sd, color="red", linestyle="--")
#plt.axvline(Amax_t, color="lime", linewidth=2)
plt.xlabel("Amax (km)")
plt.ylabel("\# models")
plt.yscale("log")
#plt.ylim(0,1000)

plt.subplot(612)
plt.hist(AAmin_real, bins=100, color="C1")
plt.xlabel("Amin (km)")
plt.ylabel("\# models")
#plt.axvline(Amin_best, color="red", linewidth=2)
#plt.axvline(Amin_mean-Amin_sd, color="red", linestyle="--")
#plt.axvline(Amin_mean+Amin_sd, color="red", linestyle="--")
#plt.axvline(Amin_t, color="lime", linewidth=2)
plt.yscale("log")
#plt.ylim(0,1000)

plt.subplot(613)
plt.hist(pphi, bins=100, color="C2")
#plt.axvline(Phi_best, color="red", linewidth=2)
#plt.axvline(phi_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("Phi angle (degrees)")
plt.yscale("log")
#plt.ylim(0,1000)

plt.subplot(614)
plt.hist(dduration_real, bins=100, color="C3")
#plt.axvline(Duration_best, color="red", linewidth=2)
#plt.axvline(Duration_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("Duration (seconds)")
plt.yscale("log")
#plt.ylim(0,1000)

plt.subplot(615)
plt.hist(vv_abs, bins=100, color="C4")
#plt.axvline(v_abs_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("|v| (km/s)")
plt.yscale("log")
#plt.ylim(0,1000)

plt.subplot(616)
plt.hist(vv_ang, bins=100, color="C5")
#plt.axvline(v_angle_t, color="lime", linewidth=2)
plt.ylabel("\# models")
plt.xlabel("v angle (degrees)")
plt.yscale("log")
#plt.ylim(0,1000)

plt.savefig(result_folder+"/hist2.png")
plt.close()

#=======================================
#plt.figure(1, figsize=(11.69, 8.27))
#plt.subplot(111)
fig, axs = plt.subplots(3,2,figsize=(15, 20))
ax1 = plt.subplot(321)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(AAmax_real, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax =  max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.axvline(Amax_t, color="green", linewidth=2)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel('\$A_{max}\$ (km)')
plt.ylabel("Misfit")
plt.yscale("log")
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
plt.text(-0.05, 1.05, "A", fontweight="bold", transform=ax1.transAxes,size=20)
#plt.axvline(Amax_t, color="black", linestyle="--", linewidth=3)
#plt.colorbar(c, orientation="horizontal", label="\# model")
#plt.suptitle("Amax", fontsize=20)
#plt.savefig(result_folder+"/Amax_vs_mft.png")
#plt.close()

###################

#plt.figure(1, figsize=(11.69, 8.27))
ax2 = plt.subplot(322)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(AAmin_real, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax = max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel("\$A_{min}\$ (km)")
#plt.ylabel("Misfit")
plt.yscale("log")
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
plt.text(-0.05, 1.05, "B", fontweight="bold", transform=ax2.transAxes,size=20)

#plt.suptitle("Amin", fontsize=20)
#plt.axvline(Amin_t, color="black", linestyle="--", linewidth=3)
#plt.savefig(result_folder+"/Amin_vs_mft.png")
#plt.close()

#plt.figure(1, figsize=(11.69, 8.27))
ax3 = plt.subplot(323)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(pphi, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax =  max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel("$\Phi$ ($^\circ$)")
plt.ylabel("Misfit")
plt.yscale("log")
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
plt.text(-0.05, 1.05, "C", fontweight="bold", transform=ax3.transAxes,size=20)
#plt.suptitle("Phi", fontsize=20)
#plt.axvline(phi_t, color="black", linestyle="--", linewidth=3)
#plt.savefig(result_folder+"/Phi_vs_mft.png")
#plt.close()

#plt.figure(1, figsize=(11.69, 8.27))
ax4 = plt.subplot(324)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(dduration_real, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax =  max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel("$\Delta$ t (s)")
#plt.ylabel("Misfit")
plt.yscale("log")
#plt.suptitle("Duration", fontsize=20)
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
plt.text(-0.05, 1.05, "D", fontweight="bold", transform=ax4.transAxes,size=20)
#plt.axvline(Duration_t, color="black", linestyle="--", linewidth=3)
#plt.savefig(result_folder+"/Duration_vs_mft.png")
#plt.close()

#plt.figure(1, figsize=(8.27, 11.69))
#plt.subplot(211)
#plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.5, hspace=0.5)
#plt.scatter(rrc_mod, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax = 0.1 * max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.axvline(phi_t, color="green", linewidth=2)
#plt.xlabel("rc module")
#plt.ylabel("Misfit")
#plt.yscale("log")
#plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))

#plt.subplot(212)
#plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.5, hspace=0.5)
#plt.scatter(rrc_ang, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax = 0.1 * max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.axvline(phi_t, color="green", linewidth=2)
#plt.xlabel("rc angle")
#plt.ylabel("Misfit")
#plt.yscale("log")
#plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
#plt.savefig(result_folder+"/rc_vs_mft.png")
#plt.close()


#plt.figure(1, figsize=(11.69, 8.27))
ax5 = plt.subplot(325)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(vv_abs, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax =  max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel("|v| (km s $^{-1}$)")
plt.ylabel("Misfit")
plt.yscale("log")
#plt.suptitle("v module", fontsize=20)
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
plt.text(-0.05, 1.05, "E", fontweight="bold", transform=ax5.transAxes,size=20)
#plt.axvline(v_abs_t, color="black", linestyle="--", linewidth=3)
#plt.savefig(result_folder+"/vabs_vs_mft.png")
#plt.close()

#plt.figure(1, figsize=(11.69, 8.27))
ax6 = plt.subplot(326)
plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.3, hspace=0.3)
it = plt.scatter(vv_ang, zip(*mmisfit)[0], c=nmodel, s=30, vmin=min(nmodel), vmax =  max(nmodel), cmap=cm.rainbow, linewidth=0.5)
#plt.colorbar(it, label="iteration number")#, orientation="horizontal")
plt.xlabel("$\Theta$ ($^\circ$)")
#plt.ylabel("Misfit")
plt.yscale("log")
#plt.suptitle("V angle", fontsize=20)
plt.ylim(min(zip(*mmisfit)[0]),max(zip(*mmisfit)[0]))
#plt.axvline(v_angle_t, color="black", linestyle="--", linewidth=3)
cbaxes = fig.add_axes([0.2, 0.03, 0.6, 0.02])
cb = plt.colorbar(it, cax = cbaxes,label="iteration number", orientation="horizontal")
plt.text(-0.05, 1.05, "F", fontweight="bold", transform=ax6.transAxes,size=20)
#plt.colorbar(it, label="iteration number")
plt.savefig("/Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/templots/combined.png")
plt.close()

#==================================================================

*

python /Users/TheStuffofAlice/Dropbox/TEMPSEIS_package_v1.2_WORKING/Inversion/Plot_results/plot_results_subplot.py
